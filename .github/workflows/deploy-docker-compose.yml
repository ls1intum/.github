name: Deploy Docker Compose

on:
  workflow_call:
    inputs:
      environment:
        type: string
        description: "The deployment environment (e.g., production, staging)"
        required: true
          
      docker-compose-file:
        type: string
        default: "./compose.yaml"
        description: "Path to the Docker Compose file (Default: ./compose.yaml)"
        required: true
          
      main-image-name:
        type: string
        description: "The name of the main image for checking if it exists with the given tag"
        required: true
          
      image-tag:
        type: string
        description: "Image tag to deploy (default: pr-<number> if PR exists, latest for default branch)"
        required: true
          
      env-file-name:
        type: string
        default: ".env"
        description: "The name of the .env file to create on the VM (Default: .env)"
        required: false

      github-env-secret-names:
        type: string
        description: "List of environment variables from GitHub Secrets, separated by new lines. Example: 'SECRET1\nSECRET2\nSECRET3'"
        required: false
          
      github-env-variable-names:
        type: string
        description: "List of environment variables from GitHub Variables, separated by new lines. Example: 'VAR1\nVAR2\nVAR3'"
        required: false
    
      remove-volumes:
        type: boolean
        default: false
        description: "Remove named volumes declared in the 'volumes' section of the Compose file and anonymous volumes attached to containers"
        required: false

jobs:
  prepare-deploy:
    runs-on: ubuntu-latest
    outputs:
      image-tag-to-deploy: ${{ steps.retrieve-image-tag.outputs.image-tag-to-deploy }}
    
    steps:
      - name: Retrieve image tag to deploy
        id: retrieve-image-tag
        run: |
          if [ -n "${{ inputs.image-tag }}" ]; then
            echo "Use image-tag input ${{ inputs.image-tag }} for deployment."
            echo "image-tag-to-deploy=${{ inputs.image-tag }}" >> $GITHUB_OUTPUT
            exit 0
          fi

          REF=$(echo "${{ github.event.ref }}" | sed -n 's#^refs/heads/##p')
          echo "Check if $REF is the default branch (${{ github.event.repository.default_branch }})."
          if [ "$REF" = "${{ github.event.repository.default_branch }}" ]; then
            echo "Use latest for deployment."
            echo "image-tag-to-deploy=latest" >> $GITHUB_OUTPUT
            exit 0
          fi

          PULLS=$(curl -s -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" "https://api.github.com/repos/${{ github.repository }}/pulls?head=${{ github.repository_owner }}:${REF}")
          PR_NUMBER=$(echo "$PULLS" | jq -r '.[0].number')

          if [ -z "$PR_NUMBER" ]; then
            echo "No PR found for branch $REF."
            exit 1
          else
            echo "PR #$PR_NUMBER found for branch $REF."
            echo "Use image-tag pr-$PR_NUMBER for deployment."
            echo "image-tag-to-deploy=pr-$PR_NUMBER" >> $GITHUB_OUTPUT
          fi

      - name: Check if image exists
        run: |
          IMAGE_NAME="${{ inputs.main-image-name }}"
          IMAGE_TAG="${{ steps.retrieve-image-tag.outputs.image-tag-to-deploy }}"

          TAG_EXISTS=$(curl -s -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
            https://ghcr.io/v2/${IMAGE_NAME}/tags/list \
            | jq -r --arg TAG "${IMAGE_TAG}" '.tags[] | select(. == $TAG)')
          
          if [ -z "$TAG_EXISTS" ]; then
            echo "Image ${IMAGE_NAME}:${IMAGE_TAG} does not exist."
            exit 1
          else
            echo "Image ${IMAGE_NAME}:${IMAGE_TAG} exists."
          fi

  deploy:
    needs: prepare-deploy
    runs-on: ubuntu-latest
    environment: 
      name: ${{ inputs.environment }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Extract basename of docker-compose-file
        id: extract_basename
        run: |
          BASENAME=$(basename "${{ inputs.docker-compose-file }}")
          echo "basename=$BASENAME" >> $GITHUB_OUTPUT

          # Copy the file to the base directory
          cp "${{ inputs.docker-compose-file }}" "$BASENAME"
        shell: bash

      - name: SSH to VM and execute docker compose down (if exists)
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ vars.VM_HOST }}
          username: ${{ vars.VM_USERNAME }}
          key: ${{ secrets.VM_SSH_PRIVATE_KEY }}
          proxy_host: ${{ vars.DEPLOYMENT_GATEWAY_HOST }}
          proxy_username: ${{ vars.DEPLOYMENT_GATEWAY_USER }}
          proxy_key: ${{ secrets.DEPLOYMENT_GATEWAY_SSH_KEY }}
          proxy_port: ${{ vars.DEPLOYMENT_GATEWAY_PORT }}
          script: |
            #!/bin/bash
            set -e  # Exit immediately if a command exits with a non-zero status

            COMPOSE_FILE="${{ steps.extract_basename.outputs.basename }}"

            # Check if docker-compose.prod.yml exists
            if [ -f "$COMPOSE_FILE" ]; then
              echo "$COMPOSE_FILE found."
          
              # Check if .env with env-file-name exists
              if [ -f "${{ inputs.env-file-name }}" ]; then
                docker compose -f "$COMPOSE_FILE" --env-file="${{ inputs.env-file-name }}" down --remove-orphans --rmi all ${{ inputs.remove-volumes && '--volumes' || '' }}
              else
                docker compose -f "$COMPOSE_FILE" down --remove-orphans --rmi all
              fi
            else
              echo "$COMPOSE_FILE does not exist. Skipping docker compose down."
            fi

      - name: Copy docker compose file to VM host
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ vars.VM_HOST }}
          username: ${{ vars.VM_USERNAME }}
          key: ${{ secrets.VM_SSH_PRIVATE_KEY }}
          proxy_host: ${{ vars.DEPLOYMENT_GATEWAY_HOST }}
          proxy_username: ${{ vars.DEPLOYMENT_GATEWAY_USER }}
          proxy_key: ${{ secrets.DEPLOYMENT_GATEWAY_SSH_KEY }}
          proxy_port: ${{ vars.DEPLOYMENT_GATEWAY_PORT }}
          source: ${{ steps.extract_basename.outputs.basename }}
          target: /home/${{ vars.VM_USERNAME }}

      - name: Create environment file content
        id: create-env-file
        env:
          GH_ENV_SECRETS: ${{ toJson(secrets) }}
          GH_ENV_VARS: ${{ toJson(vars) }}
        run: |
          echo "GH_ENV_SECRETS=$GH_ENV_SECRETS"
          echo "GH_ENV_VARS=$GH_ENV_VARS"

          # Write test file to steps.create-env-file.outputs.content for debugging
          ENV_CONTENT="ENVIRONMENT=${{ inputs.environment }}\nIMAGE_TAG=${{ needs.prepare-deploy.outputs.image-tag-to-deploy }}\n"
          {

            echo "env-file-content<<EOF"
            echo -e "$ENV_CONTENT"
            echo "EOF"
          } >> $GITHUB_OUTPUT


          # # Initialize ENV_CONTENT with environment and image tag
          # ENV_CONTENT="ENVIRONMENT=${{ inputs.environment }}\nIMAGE_TAG=${{ needs.prepare-deploy.outputs.image-tag-to-deploy }}"

          # echo "Initializing ENV_CONTENT with environment and image tag."

          # # Function to escape double quotes
          # escape_quotes() {
          #   echo "$1" | sed 's/"/\\"/g'
          # }

          # Append secrets
          # if [ -n "${{ inputs.github-env-secret-names }}" ]; then
          #   echo "Appending secrets to ENV_CONTENT."
          #   IFS=$'\n' read -rd '' -a secret_names <<< "${{ inputs.github-env-secret-names }}"
          #   for secret in "${secret_names[@]}"; do
          #     # Trim any leading/trailing whitespace
          #     secret=$(echo "$secret" | xargs)
          #     if [ -n "$secret" ]; then
          #       # Extract secret value from GH_ENV_SECRETS JSON
          #       secret_value=$(echo "$GH_ENV_SECRETS" | jq -r --arg key "$secret" '.[$key] // empty')
          #       if [ -n "$secret_value" ] && [ "$secret_value" != "null" ]; then
          #         # Escape double quotes in secret_value
          #         escaped_value=$(escape_quotes "$secret_value")
          #         ENV_CONTENT+="${secret}=\"${escaped_value}\"\n"
          #       else
          #         echo "Warning: Secret '$secret' not found or is empty."
          #       fi
          #     fi
          #   done
          # fi

          # # Append variables
          # if [ -n "${{ inputs.github-env-variable-names }}" ]; then
          #   echo "Appending variables to ENV_CONTENT."
          #   IFS=$'\n' read -rd '' -a var_names <<< "${{ inputs.github-env-variable-names }}"
          #   for var in "${var_names[@]}"; do
          #     # Trim any leading/trailing whitespace
          #     var=$(echo "$var" | xargs)
          #     if [ -n "$var" ]; then
          #       # Extract variable value from GH_ENV_VARS JSON
          #       var_value=$(echo "$GH_ENV_VARS" | jq -r --arg key "$var" '.[$key] // empty')
          #       if [ -n "$var_value" ] && [ "$var_value" != "null" ]; then
          #         # Escape double quotes in var_value
          #         escaped_var_value=$(escape_quotes "$var_value")
          #         ENV_CONTENT+="${var}=\"${escaped_var_value}\"\n"
          #       else
          #         echo "Warning: Variable '$var' not found or is empty."
          #       fi
          #     fi
          #   done
          # fi

          # # Remove trailing newline
          # ENV_CONTENT=$(echo -e "$ENV_CONTENT" | sed '$ s/\n$//')

          # echo "Final ENV_CONTENT:"
          # echo -e "$ENV_CONTENT"

          # # Set output
          # {
          #   echo "env-file-content<<EOF"
          #   echo -e "$ENV_CONTENT"
          #   echo "EOF"
          # } >> $GITHUB_OUTPUT

      - name: SSH to VM and create ${{ inputs.env-file-name }} file
        uses: appleboy/ssh-action@v1.0.3
        env:
          ENV_FILE_CONTENT: ${{ steps.create-env-file.outputs.content }}
        with:
          host: ${{ vars.VM_HOST }}
          username: ${{ vars.VM_USERNAME }}
          key: ${{ secrets.VM_SSH_PRIVATE_KEY }}
          proxy_host: ${{ vars.DEPLOYMENT_GATEWAY_HOST }}
          proxy_username: ${{ vars.DEPLOYMENT_GATEWAY_USER }}
          proxy_key: ${{ secrets.DEPLOYMENT_GATEWAY_SSH_KEY }}
          proxy_port: ${{ vars.DEPLOYMENT_GATEWAY_PORT }}
          script: |
            ENV_FILE="${{ inputs.env-file-name }}"
            echo "$ENV_FILE_CONTENT" > "$ENV_FILE"

      - name: SSH to VM and execute docker compose up
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ vars.VM_HOST }}
          username: ${{ vars.VM_USERNAME }}
          key: ${{ secrets.VM_SSH_PRIVATE_KEY }}
          proxy_host: ${{ vars.DEPLOYMENT_GATEWAY_HOST }}
          proxy_username: ${{ vars.DEPLOYMENT_GATEWAY_USER }}
          proxy_key: ${{ secrets.DEPLOYMENT_GATEWAY_SSH_KEY }}
          proxy_port: ${{ vars.DEPLOYMENT_GATEWAY_PORT }}
          script: |
            docker compose -f ${{ steps.extract_basename.outputs.basename }} --env-file=${{ inputs.env-file-name }} up --pull=always -d
